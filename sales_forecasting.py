# -*- coding: utf-8 -*-
"""Sales Forecasting

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10wnakLH6llYPqJX2Hj0imRcAQnoHolUF

### Problem Statement
Forecast the sales of a product to plan how much money should be spent on advertisements. This is because the sale of a product is usually proportional to the money spent on advertisements. To analyse this, the dataset has the following attributes:         

|Attribute|Description|
|-|-|
|TV| TV advertising budget in thousands of dollars.|
|Radio| Radio advertising budget in thousands of dollars.|
|Newspaper| Newspaper advertising budget in thousands of dollars.|
|Sales| Product Sales in thousands of dollars.|

  **Source:** https://www.kaggle.com/ishaanv/ISLR-Auto

**Dataset Link:** https://student-datasets-bucket.s3.ap-south-1.amazonaws.com/whitehat-ds-datasets/advertising.csv
"""

# Importing modules
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
# Loading the dataset
df = pd.read_csv('https://student-datasets-bucket.s3.ap-south-1.amazonaws.com/whitehat-ds-datasets/advertising.csv')
print(df.head())

# Checking for null values
print(df.isna().sum())

# Splitting the dataset into dependent and independent features
features_df = df.drop('Sales', axis=1)
target_df = df['Sales']
print(features_df.head())

print(target_df.head())

# Normalising the feature variables using 'StandardScaler'.
# Importing 'StandardScaler' from 'sklearn.preprocessing' module.
from sklearn.preprocessing import StandardScaler
std_scale = StandardScaler()
scaled_features_array = std_scale.fit_transform(features_df)
# Converting the scaled features array obtained from 'fit_transform()' function into a DataFrame.
scaled_features = pd.DataFrame(scaled_features_array)
print(scaled_features.head())

# Splitting the DataFrame into the train and test sets.
# Performing train-test split using 'train_test_split' function.
from sklearn.model_selection import train_test_split

x_train, x_test, y_train, y_test = train_test_split(scaled_features, target_df, test_size=.33, random_state=42)
print(f'X train shape{x_train.shape}\nX test shape: {x_test.shape}\nY train shape: {y_train.shape}\nY test shape: {y_test.shape}')

# Plotting accuracy scores of train and test sets for 1 to 20 neighbours.
from sklearn.neighbors import KNeighborsRegressor
# Creating two lists 'acc_train' and 'acc_test'
acc_train = []
acc_test = []
# 'for' loop with k ranging from 1 to 20.
for i in range(1,21):
  # Inside 'for' loop
  knr = KNeighborsRegressor(n_neighbors=i)
  # appending accuracy scores to the lists.
  knr.fit(x_train, y_train)
  acc_train.append(knr.score(x_train, y_train))
  acc_test.append(knr.score(x_test, y_test))
# line plots with range(1, 21) on x-axis & 'acc_train' and 'acc_test' on y-axis.
plt.figure(figsize=(20,5))
plt.plot(range(1,21), acc_train, color='red')
plt.plot(range(1,21), acc_test, color='green')
print(plt.show())

# Training kNN regressor model

# Performing prediction using 'predict()' function.
knr = KNeighborsRegressor(n_neighbors=2)
knr.fit(x_train, y_train)
# Calling the 'score()' function to check the accuracy score of the train set and test set.
knr.score(x_train, y_train), knr.score(x_test, y_test)